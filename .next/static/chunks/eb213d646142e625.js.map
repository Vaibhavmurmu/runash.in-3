{
  "version": 3,
  "sources": [],
  "debugId": "80bc44b5-087f-122e-42b8-d67517cd4a91",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/cjs/_interop_require_default.cjs","turbopack:///[project]/node_modules/.pnpm/next@16.0.10_@babel+core@7.28.5_@opentelemetry+api@1.9.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/src/shared/lib/utils/warn-once.ts","turbopack:///[project]/node_modules/.pnpm/next@16.0.10_@babel+core@7.28.5_@opentelemetry+api@1.9.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/src/shared/lib/router/utils/disable-smooth-scroll.ts","turbopack:///[project]/node_modules/.pnpm/next@16.0.10_@babel+core@7.28.5_@opentelemetry+api@1.9.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/src/client/components/builtin/global-error.tsx","turbopack:///[project]/node_modules/.pnpm/@sentry+nextjs@10.32.1_@opentelemetry+context-async-hooks@2.2.0_@opentelemetry+api@1.9._1af1e4771d912ccd1a9716d5ad598689/node_modules/@sentry/nextjs/src/common/debug-build.ts","turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.32.1/node_modules/@sentry/core/src/attributes.ts","turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.32.1/node_modules/@sentry/core/src/utils/trace-info.ts","turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.32.1/node_modules/@sentry/core/src/logs/constants.ts","turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.32.1/node_modules/@sentry/core/src/logs/envelope.ts","turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.32.1/node_modules/@sentry/core/src/logs/internal.ts","turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.32.1/node_modules/@sentry/core/src/utils/debug-ids.ts","turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.32.1/node_modules/@sentry/core/src/utils/syncpromise.ts","turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.32.1/node_modules/@sentry/core/src/eventProcessors.ts","turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.32.1/node_modules/@sentry/core/src/exports.ts","turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.32.1/node_modules/@sentry/core/src/utils/prepareEvent.ts","turbopack:///[project]/node_modules/.pnpm/next@16.0.10_@babel+core@7.28.5_@opentelemetry+api@1.9.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/src/shared/lib/head-manager-context.shared-runtime.ts"],"sourcesContent":["\"use strict\";\n\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n}\nexports._ = _interop_require_default;\n","let warnOnce = (_: string) => {}\nif (process.env.NODE_ENV !== 'production') {\n  const warnings = new Set<string>()\n  warnOnce = (msg: string) => {\n    if (!warnings.has(msg)) {\n      console.warn(msg)\n    }\n    warnings.add(msg)\n  }\n}\n\nexport { warnOnce }\n","import { warnOnce } from '../../utils/warn-once'\n\n/**\n * Run function with `scroll-behavior: auto` applied to `<html/>`.\n * This css change will be reverted after the function finishes.\n */\nexport function disableSmoothScrollDuringRouteTransition(\n  fn: () => void,\n  options: { dontForceLayout?: boolean; onlyHashChange?: boolean } = {}\n) {\n  // if only the hash is changed, we don't need to disable smooth scrolling\n  // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX\n  if (options.onlyHashChange) {\n    fn()\n    return\n  }\n\n  const htmlElement = document.documentElement\n  const hasDataAttribute = htmlElement.dataset.scrollBehavior === 'smooth'\n\n  if (!hasDataAttribute) {\n    // Warn if smooth scrolling is detected but no data attribute is present\n    if (\n      process.env.NODE_ENV === 'development' &&\n      getComputedStyle(htmlElement).scrollBehavior === 'smooth'\n    ) {\n      warnOnce(\n        'Detected `scroll-behavior: smooth` on the `<html>` element. To disable smooth scrolling during route transitions, ' +\n          'add `data-scroll-behavior=\"smooth\"` to your <html> element. ' +\n          'Learn more: https://nextjs.org/docs/messages/missing-data-scroll-behavior'\n      )\n    }\n    // No smooth scrolling configured, run directly without style manipulation\n    fn()\n    return\n  }\n\n  // Proceed with temporarily disabling smooth scrolling\n  const existing = htmlElement.style.scrollBehavior\n  htmlElement.style.scrollBehavior = 'auto'\n  if (!options.dontForceLayout) {\n    // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n    // Otherwise it will not pickup the change in scrollBehavior\n    // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n    htmlElement.getClientRects()\n  }\n  fn()\n  htmlElement.style.scrollBehavior = existing\n}\n","'use client'\n\nimport { HandleISRError } from '../handle-isr-error'\n\nconst styles = {\n  error: {\n    // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n    fontFamily:\n      'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n    height: '100vh',\n    textAlign: 'center',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  text: {\n    fontSize: '14px',\n    fontWeight: 400,\n    lineHeight: '28px',\n    margin: '0 8px',\n  },\n} as const\n\nexport type GlobalErrorComponent = React.ComponentType<{\n  error: any\n}>\nfunction DefaultGlobalError({ error }: { error: any }) {\n  const digest: string | undefined = error?.digest\n  return (\n    <html id=\"__next_error__\">\n      <head></head>\n      <body>\n        <HandleISRError error={error} />\n        <div style={styles.error}>\n          <div>\n            <h2 style={styles.text}>\n              Application error: a {digest ? 'server' : 'client'}-side exception\n              has occurred while loading {window.location.hostname} (see the{' '}\n              {digest ? 'server logs' : 'browser console'} for more\n              information).\n            </h2>\n            {digest ? <p style={styles.text}>{`Digest: ${digest}`}</p> : null}\n          </div>\n        </div>\n      </body>\n    </html>\n  )\n}\n\n// Exported so that the import signature in the loaders can be identical to user\n// supplied custom global error signatures.\nexport default DefaultGlobalError\n","declare const __DEBUG_BUILD__: boolean;\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nexport const DEBUG_BUILD = __DEBUG_BUILD__;\n","import type { DurationUnit, FractionUnit, InformationUnit } from './types-hoist/measurement';\n\nexport type RawAttributes<T> = T & ValidatedAttributes<T>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type RawAttribute<T> = T extends { value: any } | { unit: any } ? AttributeObject : T;\n\nexport type Attributes = Record<string, TypedAttributeValue>;\n\nexport type AttributeValueType = string | number | boolean | Array<string> | Array<number> | Array<boolean>;\n\ntype AttributeTypeMap = {\n  string: string;\n  integer: number;\n  double: number;\n  boolean: boolean;\n  'string[]': Array<string>;\n  'integer[]': Array<number>;\n  'double[]': Array<number>;\n  'boolean[]': Array<boolean>;\n};\n\n/* Generates a type from the AttributeTypeMap like:\n  | { value: string; type: 'string' }\n  | { value: number; type: 'integer' }\n  | { value: number; type: 'double' }\n */\ntype AttributeUnion = {\n  [K in keyof AttributeTypeMap]: {\n    value: AttributeTypeMap[K];\n    type: K;\n  };\n}[keyof AttributeTypeMap];\n\nexport type TypedAttributeValue = AttributeUnion & { unit?: AttributeUnit };\n\nexport type AttributeObject = {\n  value: unknown;\n  unit?: AttributeUnit;\n};\n\n// Unfortunately, we loose type safety if we did something like Exclude<MeasurementUnit, string>\n// so therefore we unionize between the three supported unit categories.\ntype AttributeUnit = DurationUnit | InformationUnit | FractionUnit;\n\n/* If an attribute has either a 'value' or 'unit' property, we use the ValidAttributeObject type. */\nexport type ValidatedAttributes<T> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [K in keyof T]: T[K] extends { value: any } | { unit: any } ? AttributeObject : unknown;\n};\n\n/**\n * Type-guard: The attribute object has the shape the official attribute object (value, type, unit).\n * https://develop.sentry.dev/sdk/telemetry/scopes/#setting-attributes\n */\nexport function isAttributeObject(maybeObj: unknown): maybeObj is AttributeObject {\n  return (\n    typeof maybeObj === 'object' &&\n    maybeObj != null &&\n    !Array.isArray(maybeObj) &&\n    Object.keys(maybeObj).includes('value')\n  );\n}\n\n/**\n * Converts an attribute value to a typed attribute value.\n *\n * For now, we intentionally only support primitive values and attribute objects with primitive values.\n * If @param useFallback is true, we stringify non-primitive values to a string attribute value. Otherwise\n * we return `undefined` for unsupported values.\n *\n * @param value - The value of the passed attribute.\n * @param useFallback - If true, unsupported values will be stringified to a string attribute value.\n *                      Defaults to false. In this case, `undefined` is returned for unsupported values.\n * @returns The typed attribute.\n */\nexport function attributeValueToTypedAttributeValue(\n  rawValue: unknown,\n  useFallback?: boolean,\n): TypedAttributeValue | void {\n  const { value, unit } = isAttributeObject(rawValue) ? rawValue : { value: rawValue, unit: undefined };\n  const attributeValue = getTypedAttributeValue(value);\n  const checkedUnit = unit && typeof unit === 'string' ? { unit } : {};\n  if (attributeValue) {\n    return { ...attributeValue, ...checkedUnit };\n  }\n\n  if (!useFallback) {\n    return;\n  }\n\n  // Fallback: stringify the value\n  // TODO(v11): be smarter here and use String constructor if stringify fails\n  // (this is a breaking change for already existing attribute values)\n  let stringValue = '';\n  try {\n    stringValue = JSON.stringify(value) ?? '';\n  } catch {\n    // Do nothing\n  }\n  return {\n    value: stringValue,\n    type: 'string',\n    ...checkedUnit,\n  };\n}\n\n/**\n * Serializes raw attributes to typed attributes as expected in our envelopes.\n *\n * @param attributes The raw attributes to serialize.\n * @param fallback   If true, unsupported values will be stringified to a string attribute value.\n *                   Defaults to false. In this case, `undefined` is returned for unsupported values.\n *\n * @returns The serialized attributes.\n */\nexport function serializeAttributes<T>(attributes: RawAttributes<T>, fallback: boolean = false): Attributes {\n  const serializedAttributes: Attributes = {};\n  for (const [key, value] of Object.entries(attributes)) {\n    const typedValue = attributeValueToTypedAttributeValue(value, fallback);\n    if (typedValue) {\n      serializedAttributes[key] = typedValue;\n    }\n  }\n  return serializedAttributes;\n}\n\n/**\n * NOTE: We intentionally do not return anything for non-primitive values:\n *  - array support will come in the future but if we stringify arrays now,\n *    sending arrays (unstringified) later will be a subtle breaking change.\n *  - Objects are not supported yet and product support is still TBD.\n *  - We still keep the type signature for TypedAttributeValue wider to avoid a\n *    breaking change once we add support for non-primitive values.\n *  - Once we go back to supporting arrays and stringifying all other values,\n *    we already implemented the serialization logic here:\n *    https://github.com/getsentry/sentry-javascript/pull/18165\n */\nfunction getTypedAttributeValue(value: unknown): TypedAttributeValue | void {\n  const primitiveType =\n    typeof value === 'string'\n      ? 'string'\n      : typeof value === 'boolean'\n        ? 'boolean'\n        : typeof value === 'number' && !Number.isNaN(value)\n          ? Number.isInteger(value)\n            ? 'integer'\n            : 'double'\n          : null;\n  if (primitiveType) {\n    // @ts-expect-error - TS complains because {@link TypedAttributeValue} is strictly typed to\n    // avoid setting the wrong `type` on the attribute value.\n    // In this case, getPrimitiveType already does the check but TS doesn't know that.\n    // The \"clean\" alternative is to return an object per `typeof value` case\n    // but that would require more bundle size\n    // Therefore, we ignore it.\n    return { value, type: primitiveType };\n  }\n}\n","import type { Client } from '../client';\nimport { getTraceContextFromScope, withScope } from '../currentScopes';\nimport type { Scope } from '../scope';\nimport {\n  getDynamicSamplingContextFromScope,\n  getDynamicSamplingContextFromSpan,\n} from '../tracing/dynamicSamplingContext';\nimport type { TraceContext } from '../types-hoist/context';\nimport type { DynamicSamplingContext } from '../types-hoist/envelope';\nimport { getActiveSpan, spanToTraceContext } from './spanUtils';\n\n/** Extract trace information from scope */\nexport function _getTraceInfoFromScope(\n  client: Client,\n  scope: Scope | undefined,\n): [dynamicSamplingContext: Partial<DynamicSamplingContext> | undefined, traceContext: TraceContext | undefined] {\n  if (!scope) {\n    return [undefined, undefined];\n  }\n\n  return withScope(scope, () => {\n    const span = getActiveSpan();\n    const traceContext = span ? spanToTraceContext(span) : getTraceContextFromScope(scope);\n    const dynamicSamplingContext = span\n      ? getDynamicSamplingContextFromSpan(span)\n      : getDynamicSamplingContextFromScope(client, scope);\n    return [dynamicSamplingContext, traceContext];\n  });\n}\n","import type { LogSeverityLevel } from '../types-hoist/log';\n\n/**\n * Maps a log severity level to a log severity number.\n *\n * @see LogSeverityLevel\n */\nexport const SEVERITY_TEXT_TO_SEVERITY_NUMBER: Partial<Record<LogSeverityLevel, number>> = {\n  trace: 1,\n  debug: 5,\n  info: 9,\n  warn: 13,\n  error: 17,\n  fatal: 21,\n};\n","import type { DsnComponents } from '../types-hoist/dsn';\nimport type { LogContainerItem, LogEnvelope } from '../types-hoist/envelope';\nimport type { SerializedLog } from '../types-hoist/log';\nimport type { SdkMetadata } from '../types-hoist/sdkmetadata';\nimport { dsnToString } from '../utils/dsn';\nimport { createEnvelope } from '../utils/envelope';\n\n/**\n * Creates a log container envelope item for a list of logs.\n *\n * @param items - The logs to include in the envelope.\n * @returns The created log container envelope item.\n */\nexport function createLogContainerEnvelopeItem(items: Array<SerializedLog>): LogContainerItem {\n  return [\n    {\n      type: 'log',\n      item_count: items.length,\n      content_type: 'application/vnd.sentry.items.log+json',\n    },\n    {\n      items,\n    },\n  ];\n}\n\n/**\n * Creates an envelope for a list of logs.\n *\n * Logs from multiple traces can be included in the same envelope.\n *\n * @param logs - The logs to include in the envelope.\n * @param metadata - The metadata to include in the envelope.\n * @param tunnel - The tunnel to include in the envelope.\n * @param dsn - The DSN to include in the envelope.\n * @returns The created envelope.\n */\nexport function createLogEnvelope(\n  logs: Array<SerializedLog>,\n  metadata?: SdkMetadata,\n  tunnel?: string,\n  dsn?: DsnComponents,\n): LogEnvelope {\n  const headers: LogEnvelope[0] = {};\n\n  if (metadata?.sdk) {\n    headers.sdk = {\n      name: metadata.sdk.name,\n      version: metadata.sdk.version,\n    };\n  }\n\n  if (!!tunnel && !!dsn) {\n    headers.dsn = dsnToString(dsn);\n  }\n\n  return createEnvelope<LogEnvelope>(headers, [createLogContainerEnvelopeItem(logs)]);\n}\n","import { serializeAttributes } from '../attributes';\nimport { getGlobalSingleton } from '../carrier';\nimport type { Client } from '../client';\nimport { getClient, getCurrentScope, getGlobalScope, getIsolationScope } from '../currentScopes';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { Scope, ScopeData } from '../scope';\nimport type { Integration } from '../types-hoist/integration';\nimport type { Log, SerializedLog } from '../types-hoist/log';\nimport { mergeScopeData } from '../utils/applyScopeDataToEvent';\nimport { consoleSandbox, debug } from '../utils/debug-logger';\nimport { isParameterizedString } from '../utils/is';\nimport { _getSpanForScope } from '../utils/spanOnScope';\nimport { timestampInSeconds } from '../utils/time';\nimport { _getTraceInfoFromScope } from '../utils/trace-info';\nimport { SEVERITY_TEXT_TO_SEVERITY_NUMBER } from './constants';\nimport { createLogEnvelope } from './envelope';\n\nconst MAX_LOG_BUFFER_SIZE = 100;\n\n/**\n * Sets a log attribute if the value exists and the attribute key is not already present.\n *\n * @param logAttributes - The log attributes object to modify.\n * @param key - The attribute key to set.\n * @param value - The value to set (only sets if truthy and key not present).\n * @param setEvenIfPresent - Whether to set the attribute if it is present. Defaults to true.\n */\nfunction setLogAttribute(\n  logAttributes: Record<string, unknown>,\n  key: string,\n  value: unknown,\n  setEvenIfPresent = true,\n): void {\n  if (value && (!logAttributes[key] || setEvenIfPresent)) {\n    logAttributes[key] = value;\n  }\n}\n\n/**\n * Captures a serialized log event and adds it to the log buffer for the given client.\n *\n * @param client - A client. Uses the current client if not provided.\n * @param serializedLog - The serialized log event to capture.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_captureSerializedLog(client: Client, serializedLog: SerializedLog): void {\n  const bufferMap = _getBufferMap();\n  const logBuffer = _INTERNAL_getLogBuffer(client);\n\n  if (logBuffer === undefined) {\n    bufferMap.set(client, [serializedLog]);\n  } else {\n    if (logBuffer.length >= MAX_LOG_BUFFER_SIZE) {\n      _INTERNAL_flushLogsBuffer(client, logBuffer);\n      bufferMap.set(client, [serializedLog]);\n    } else {\n      bufferMap.set(client, [...logBuffer, serializedLog]);\n    }\n  }\n}\n\n/**\n * Captures a log event and sends it to Sentry.\n *\n * @param log - The log event to capture.\n * @param scope - A scope. Uses the current scope if not provided.\n * @param client - A client. Uses the current client if not provided.\n * @param captureSerializedLog - A function to capture the serialized log.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_captureLog(\n  beforeLog: Log,\n  currentScope = getCurrentScope(),\n  captureSerializedLog: (client: Client, log: SerializedLog) => void = _INTERNAL_captureSerializedLog,\n): void {\n  const client = currentScope?.getClient() ?? getClient();\n  if (!client) {\n    DEBUG_BUILD && debug.warn('No client available to capture log.');\n    return;\n  }\n\n  const { release, environment, enableLogs = false, beforeSendLog } = client.getOptions();\n  if (!enableLogs) {\n    DEBUG_BUILD && debug.warn('logging option not enabled, log will not be captured.');\n    return;\n  }\n\n  const [, traceContext] = _getTraceInfoFromScope(client, currentScope);\n\n  const processedLogAttributes = {\n    ...beforeLog.attributes,\n  };\n\n  const {\n    user: { id, email, username },\n    attributes: scopeAttributes = {},\n  } = getMergedScopeData(currentScope);\n\n  setLogAttribute(processedLogAttributes, 'user.id', id, false);\n  setLogAttribute(processedLogAttributes, 'user.email', email, false);\n  setLogAttribute(processedLogAttributes, 'user.name', username, false);\n\n  setLogAttribute(processedLogAttributes, 'sentry.release', release);\n  setLogAttribute(processedLogAttributes, 'sentry.environment', environment);\n\n  const { name, version } = client.getSdkMetadata()?.sdk ?? {};\n  setLogAttribute(processedLogAttributes, 'sentry.sdk.name', name);\n  setLogAttribute(processedLogAttributes, 'sentry.sdk.version', version);\n\n  const replay = client.getIntegrationByName<\n    Integration & {\n      getReplayId: (onlyIfSampled?: boolean) => string;\n      getRecordingMode: () => 'session' | 'buffer' | undefined;\n    }\n  >('Replay');\n\n  const replayId = replay?.getReplayId(true);\n  setLogAttribute(processedLogAttributes, 'sentry.replay_id', replayId);\n\n  if (replayId && replay?.getRecordingMode() === 'buffer') {\n    // We send this so we can identify cases where the replayId is attached but the replay itself might not have been sent to Sentry\n    setLogAttribute(processedLogAttributes, 'sentry._internal.replay_is_buffering', true);\n  }\n\n  const beforeLogMessage = beforeLog.message;\n  if (isParameterizedString(beforeLogMessage)) {\n    const { __sentry_template_string__, __sentry_template_values__ = [] } = beforeLogMessage;\n    if (__sentry_template_values__?.length) {\n      processedLogAttributes['sentry.message.template'] = __sentry_template_string__;\n    }\n    __sentry_template_values__.forEach((param, index) => {\n      processedLogAttributes[`sentry.message.parameter.${index}`] = param;\n    });\n  }\n\n  const span = _getSpanForScope(currentScope);\n  // Add the parent span ID to the log attributes for trace context\n  setLogAttribute(processedLogAttributes, 'sentry.trace.parent_span_id', span?.spanContext().spanId);\n\n  const processedLog = { ...beforeLog, attributes: processedLogAttributes };\n\n  client.emit('beforeCaptureLog', processedLog);\n\n  // We need to wrap this in `consoleSandbox` to avoid recursive calls to `beforeSendLog`\n  const log = beforeSendLog ? consoleSandbox(() => beforeSendLog(processedLog)) : processedLog;\n  if (!log) {\n    client.recordDroppedEvent('before_send', 'log_item', 1);\n    DEBUG_BUILD && debug.warn('beforeSendLog returned null, log will not be captured.');\n    return;\n  }\n\n  const { level, message, attributes: logAttributes = {}, severityNumber } = log;\n\n  const serializedLog: SerializedLog = {\n    timestamp: timestampInSeconds(),\n    level,\n    body: message,\n    trace_id: traceContext?.trace_id,\n    severity_number: severityNumber ?? SEVERITY_TEXT_TO_SEVERITY_NUMBER[level],\n    attributes: {\n      ...serializeAttributes(scopeAttributes),\n      ...serializeAttributes(logAttributes, true),\n    },\n  };\n\n  captureSerializedLog(client, serializedLog);\n\n  client.emit('afterCaptureLog', log);\n}\n\n/**\n * Flushes the logs buffer to Sentry.\n *\n * @param client - A client.\n * @param maybeLogBuffer - A log buffer. Uses the log buffer for the given client if not provided.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_flushLogsBuffer(client: Client, maybeLogBuffer?: Array<SerializedLog>): void {\n  const logBuffer = maybeLogBuffer ?? _INTERNAL_getLogBuffer(client) ?? [];\n  if (logBuffer.length === 0) {\n    return;\n  }\n\n  const clientOptions = client.getOptions();\n  const envelope = createLogEnvelope(logBuffer, clientOptions._metadata, clientOptions.tunnel, client.getDsn());\n\n  // Clear the log buffer after envelopes have been constructed.\n  _getBufferMap().set(client, []);\n\n  client.emit('flushLogs');\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope);\n}\n\n/**\n * Returns the log buffer for a given client.\n *\n * Exported for testing purposes.\n *\n * @param client - The client to get the log buffer for.\n * @returns The log buffer for the given client.\n */\nexport function _INTERNAL_getLogBuffer(client: Client): Array<SerializedLog> | undefined {\n  return _getBufferMap().get(client);\n}\n\n/**\n * Get the scope data for the current scope after merging with the\n * global scope and isolation scope.\n *\n * @param currentScope - The current scope.\n * @returns The scope data.\n */\nfunction getMergedScopeData(currentScope: Scope): ScopeData {\n  const scopeData = getGlobalScope().getScopeData();\n  mergeScopeData(scopeData, getIsolationScope().getScopeData());\n  mergeScopeData(scopeData, currentScope.getScopeData());\n  return scopeData;\n}\n\nfunction _getBufferMap(): WeakMap<Client, Array<SerializedLog>> {\n  // The reference to the Client <> LogBuffer map is stored on the carrier to ensure it's always the same\n  return getGlobalSingleton('clientToLogBufferMap', () => new WeakMap<Client, Array<SerializedLog>>());\n}\n","import type { DebugImage } from '../types-hoist/debugMeta';\nimport type { StackParser } from '../types-hoist/stacktrace';\nimport { GLOBAL_OBJ } from './worldwide';\n\ntype StackString = string;\ntype CachedResult = [string, string];\n\nlet parsedStackResults: Record<StackString, CachedResult> | undefined;\nlet lastSentryKeysCount: number | undefined;\nlet lastNativeKeysCount: number | undefined;\nlet cachedFilenameDebugIds: Record<string, string> | undefined;\n\n/**\n * Returns a map of filenames to debug identifiers.\n * Supports both proprietary _sentryDebugIds and native _debugIds (e.g., from Vercel) formats.\n */\nexport function getFilenameToDebugIdMap(stackParser: StackParser): Record<string, string> {\n  const sentryDebugIdMap = GLOBAL_OBJ._sentryDebugIds;\n  const nativeDebugIdMap = GLOBAL_OBJ._debugIds;\n\n  if (!sentryDebugIdMap && !nativeDebugIdMap) {\n    return {};\n  }\n\n  const sentryDebugIdKeys = sentryDebugIdMap ? Object.keys(sentryDebugIdMap) : [];\n  const nativeDebugIdKeys = nativeDebugIdMap ? Object.keys(nativeDebugIdMap) : [];\n\n  // If the count of registered globals hasn't changed since the last call, we\n  // can just return the cached result.\n  if (\n    cachedFilenameDebugIds &&\n    sentryDebugIdKeys.length === lastSentryKeysCount &&\n    nativeDebugIdKeys.length === lastNativeKeysCount\n  ) {\n    return cachedFilenameDebugIds;\n  }\n\n  lastSentryKeysCount = sentryDebugIdKeys.length;\n  lastNativeKeysCount = nativeDebugIdKeys.length;\n\n  // Build a map of filename -> debug_id from both sources\n  cachedFilenameDebugIds = {};\n\n  if (!parsedStackResults) {\n    parsedStackResults = {};\n  }\n\n  const processDebugIds = (debugIdKeys: string[], debugIdMap: Record<string, string>): void => {\n    for (const key of debugIdKeys) {\n      const debugId = debugIdMap[key];\n      const result = parsedStackResults?.[key];\n\n      if (result && cachedFilenameDebugIds && debugId) {\n        // Use cached filename but update with current debug ID\n        cachedFilenameDebugIds[result[0]] = debugId;\n        // Update cached result with new debug ID\n        if (parsedStackResults) {\n          parsedStackResults[key] = [result[0], debugId];\n        }\n      } else if (debugId) {\n        const parsedStack = stackParser(key);\n\n        for (let i = parsedStack.length - 1; i >= 0; i--) {\n          const stackFrame = parsedStack[i];\n          const filename = stackFrame?.filename;\n\n          if (filename && cachedFilenameDebugIds && parsedStackResults) {\n            cachedFilenameDebugIds[filename] = debugId;\n            parsedStackResults[key] = [filename, debugId];\n            break;\n          }\n        }\n      }\n    }\n  };\n\n  if (sentryDebugIdMap) {\n    processDebugIds(sentryDebugIdKeys, sentryDebugIdMap);\n  }\n\n  // Native _debugIds will override _sentryDebugIds if same file\n  if (nativeDebugIdMap) {\n    processDebugIds(nativeDebugIdKeys, nativeDebugIdMap);\n  }\n\n  return cachedFilenameDebugIds;\n}\n\n/**\n * Returns a list of debug images for the given resources.\n */\nexport function getDebugImagesForResources(\n  stackParser: StackParser,\n  resource_paths: ReadonlyArray<string>,\n): DebugImage[] {\n  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);\n\n  if (!filenameDebugIdMap) {\n    return [];\n  }\n\n  const images: DebugImage[] = [];\n  for (const path of resource_paths) {\n    if (path && filenameDebugIdMap[path]) {\n      images.push({\n        type: 'sourcemap',\n        code_file: path,\n        debug_id: filenameDebugIdMap[path],\n      });\n    }\n  }\n\n  return images;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { isThenable } from './is';\n\n/** SyncPromise internal states */\nconst STATE_PENDING = 0;\nconst STATE_RESOLVED = 1;\nconst STATE_REJECTED = 2;\n\ntype State = typeof STATE_PENDING | typeof STATE_RESOLVED | typeof STATE_REJECTED;\n\n// Overloads so we can call resolvedSyncPromise without arguments and generic argument\nexport function resolvedSyncPromise(): PromiseLike<void>;\nexport function resolvedSyncPromise<T>(value: T | PromiseLike<T>): PromiseLike<T>;\n\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\nexport function resolvedSyncPromise<T>(value?: T | PromiseLike<T>): PromiseLike<T> {\n  return new SyncPromise(resolve => {\n    resolve(value);\n  });\n}\n\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\nexport function rejectedSyncPromise<T = never>(reason?: any): PromiseLike<T> {\n  return new SyncPromise((_, reject) => {\n    reject(reason);\n  });\n}\n\ntype Executor<T> = (resolve: (value?: T | PromiseLike<T> | null) => void, reject: (reason?: any) => void) => void;\n\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\nexport class SyncPromise<T> implements PromiseLike<T> {\n  private _state: State;\n  private _handlers: Array<[boolean, (value: T) => void, (reason: any) => any]>;\n  private _value: any;\n\n  public constructor(executor: Executor<T>) {\n    this._state = STATE_PENDING;\n    this._handlers = [];\n\n    this._runExecutor(executor);\n  }\n\n  /** @inheritdoc */\n  public then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,\n  ): PromiseLike<TResult1 | TResult2> {\n    return new SyncPromise((resolve, reject) => {\n      this._handlers.push([\n        false,\n        result => {\n          if (!onfulfilled) {\n            // TODO: ¯\\_(ツ)_/¯\n            // TODO: FIXME\n            resolve(result as any);\n          } else {\n            try {\n              resolve(onfulfilled(result));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n        reason => {\n          if (!onrejected) {\n            reject(reason);\n          } else {\n            try {\n              resolve(onrejected(reason));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n      ]);\n      this._executeHandlers();\n    });\n  }\n\n  /** @inheritdoc */\n  public catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,\n  ): PromiseLike<T | TResult> {\n    return this.then(val => val, onrejected);\n  }\n\n  /** @inheritdoc */\n  public finally<TResult>(onfinally?: (() => void) | null): PromiseLike<TResult> {\n    return new SyncPromise<TResult>((resolve, reject) => {\n      let val: TResult | any;\n      let isRejected: boolean;\n\n      return this.then(\n        value => {\n          isRejected = false;\n          val = value;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n        reason => {\n          isRejected = true;\n          val = reason;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n      ).then(() => {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n\n        resolve(val as unknown as any);\n      });\n    });\n  }\n\n  /** Excute the resolve/reject handlers. */\n  private _executeHandlers(): void {\n    if (this._state === STATE_PENDING) {\n      return;\n    }\n\n    const cachedHandlers = this._handlers.slice();\n    this._handlers = [];\n\n    cachedHandlers.forEach(handler => {\n      if (handler[0]) {\n        return;\n      }\n\n      if (this._state === STATE_RESOLVED) {\n        handler[1](this._value as unknown as any);\n      }\n\n      if (this._state === STATE_REJECTED) {\n        handler[2](this._value);\n      }\n\n      handler[0] = true;\n    });\n  }\n\n  /** Run the executor for the SyncPromise. */\n  private _runExecutor(executor: Executor<T>): void {\n    const setResult = (state: State, value?: T | PromiseLike<T> | any): void => {\n      if (this._state !== STATE_PENDING) {\n        return;\n      }\n\n      if (isThenable(value)) {\n        void (value as PromiseLike<T>).then(resolve, reject);\n        return;\n      }\n\n      this._state = state;\n      this._value = value;\n\n      this._executeHandlers();\n    };\n\n    const resolve = (value: unknown): void => {\n      setResult(STATE_RESOLVED, value);\n    };\n\n    const reject = (reason: unknown): void => {\n      setResult(STATE_REJECTED, reason);\n    };\n\n    try {\n      executor(resolve, reject);\n    } catch (e) {\n      reject(e);\n    }\n  }\n}\n","import { DEBUG_BUILD } from './debug-build';\nimport type { Event, EventHint } from './types-hoist/event';\nimport type { EventProcessor } from './types-hoist/eventprocessor';\nimport { debug } from './utils/debug-logger';\nimport { isThenable } from './utils/is';\nimport { rejectedSyncPromise, resolvedSyncPromise } from './utils/syncpromise';\n\n/**\n * Process an array of event processors, returning the processed event (or `null` if the event was dropped).\n */\nexport function notifyEventProcessors(\n  processors: EventProcessor[],\n  event: Event | null,\n  hint: EventHint,\n  index: number = 0,\n): PromiseLike<Event | null> {\n  try {\n    const result = _notifyEventProcessors(event, hint, processors, index);\n    return isThenable(result) ? result : resolvedSyncPromise(result);\n  } catch (error) {\n    return rejectedSyncPromise(error);\n  }\n}\n\nfunction _notifyEventProcessors(\n  event: Event | null,\n  hint: EventHint,\n  processors: EventProcessor[],\n  index: number,\n): Event | null | PromiseLike<Event | null> {\n  const processor = processors[index];\n\n  if (!event || !processor) {\n    return event;\n  }\n\n  const result = processor({ ...event }, hint);\n\n  DEBUG_BUILD && result === null && debug.log(`Event processor \"${processor.id || '?'}\" dropped event`);\n\n  if (isThenable(result)) {\n    return result.then(final => _notifyEventProcessors(final, hint, processors, index + 1));\n  }\n\n  return _notifyEventProcessors(result, hint, processors, index + 1);\n}\n","import { getClient, getCurrentScope, getIsolationScope, withIsolationScope } from './currentScopes';\nimport { DEBUG_BUILD } from './debug-build';\nimport type { CaptureContext } from './scope';\nimport { closeSession, makeSession, updateSession } from './session';\nimport { startNewTrace } from './tracing/trace';\nimport type { CheckIn, FinishedCheckIn, MonitorConfig } from './types-hoist/checkin';\nimport type { Event, EventHint } from './types-hoist/event';\nimport type { EventProcessor } from './types-hoist/eventprocessor';\nimport type { Extra, Extras } from './types-hoist/extra';\nimport type { Primitive } from './types-hoist/misc';\nimport type { Session, SessionContext } from './types-hoist/session';\nimport type { SeverityLevel } from './types-hoist/severity';\nimport type { User } from './types-hoist/user';\nimport { debug } from './utils/debug-logger';\nimport { isThenable } from './utils/is';\nimport { uuid4 } from './utils/misc';\nimport type { ExclusiveEventHintOrCaptureContext } from './utils/prepareEvent';\nimport { parseEventHintOrCaptureContext } from './utils/prepareEvent';\nimport { timestampInSeconds } from './utils/time';\nimport { GLOBAL_OBJ } from './utils/worldwide';\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured Sentry event.\n */\nexport function captureException(exception: unknown, hint?: ExclusiveEventHintOrCaptureContext): string {\n  return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param captureContext Define the level of the message or pass in additional data to attach to the message.\n * @returns the id of the captured message.\n */\nexport function captureMessage(message: string, captureContext?: CaptureContext | SeverityLevel): string {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  const level = typeof captureContext === 'string' ? captureContext : undefined;\n  const hint = typeof captureContext !== 'string' ? { captureContext } : undefined;\n  return getCurrentScope().captureMessage(message, level, hint);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured event.\n */\nexport function captureEvent(event: Event, hint?: EventHint): string {\n  return getCurrentScope().captureEvent(event, hint);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\nexport function setContext(name: string, context: { [key: string]: unknown } | null): void {\n  getIsolationScope().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nexport function setExtras(extras: Extras): void {\n  getIsolationScope().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nexport function setExtra(key: string, extra: Extra): void {\n  getIsolationScope().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nexport function setTags(tags: { [key: string]: Primitive }): void {\n  getIsolationScope().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nexport function setTag(key: string, value: Primitive): void {\n  getIsolationScope().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nexport function setUser(user: User | null): void {\n  getIsolationScope().setUser(user);\n}\n\n/**\n * The last error event id of the isolation scope.\n *\n * Warning: This function really returns the last recorded error event id on the current\n * isolation scope. If you call this function after handling a certain error and another error\n * is captured in between, the last one is returned instead of the one you might expect.\n * Also, ids of events that were never sent to Sentry (for example because\n * they were dropped in `beforeSend`) could be returned.\n *\n * @returns The last event id of the isolation scope.\n */\nexport function lastEventId(): string | undefined {\n  return getIsolationScope().lastEventId();\n}\n\n/**\n * Create a cron monitor check in and send it to Sentry.\n *\n * @param checkIn An object that describes a check in.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nexport function captureCheckIn(checkIn: CheckIn, upsertMonitorConfig?: MonitorConfig): string {\n  const scope = getCurrentScope();\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && debug.warn('Cannot capture check-in. No client defined.');\n  } else if (!client.captureCheckIn) {\n    DEBUG_BUILD && debug.warn('Cannot capture check-in. Client does not support sending check-ins.');\n  } else {\n    return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);\n  }\n\n  return uuid4();\n}\n\n/**\n * Wraps a callback with a cron monitor check in. The check in will be sent to Sentry when the callback finishes.\n *\n * @param monitorSlug The distinct slug of the monitor.\n * @param callback Callback to be monitored\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nexport function withMonitor<T>(\n  monitorSlug: CheckIn['monitorSlug'],\n  callback: () => T,\n  upsertMonitorConfig?: MonitorConfig,\n): T {\n  function runCallback(): T {\n    const checkInId = captureCheckIn({ monitorSlug, status: 'in_progress' }, upsertMonitorConfig);\n    const now = timestampInSeconds();\n\n    function finishCheckIn(status: FinishedCheckIn['status']): void {\n      captureCheckIn({ monitorSlug, status, checkInId, duration: timestampInSeconds() - now });\n    }\n    // Default behavior without isolateTrace\n    let maybePromiseResult: T;\n    try {\n      maybePromiseResult = callback();\n    } catch (e) {\n      finishCheckIn('error');\n      throw e;\n    }\n\n    if (isThenable(maybePromiseResult)) {\n      return maybePromiseResult.then(\n        r => {\n          finishCheckIn('ok');\n          return r;\n        },\n        e => {\n          finishCheckIn('error');\n          throw e;\n        },\n      ) as T;\n    }\n    finishCheckIn('ok');\n\n    return maybePromiseResult;\n  }\n\n  return withIsolationScope(() => (upsertMonitorConfig?.isolateTrace ? startNewTrace(runCallback) : runCallback()));\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nexport async function flush(timeout?: number): Promise<boolean> {\n  const client = getClient();\n  if (client) {\n    return client.flush(timeout);\n  }\n  DEBUG_BUILD && debug.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nexport async function close(timeout?: number): Promise<boolean> {\n  const client = getClient();\n  if (client) {\n    return client.close(timeout);\n  }\n  DEBUG_BUILD && debug.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Returns true if Sentry has been properly initialized.\n */\nexport function isInitialized(): boolean {\n  return !!getClient();\n}\n\n/** If the SDK is initialized & enabled. */\nexport function isEnabled(): boolean {\n  const client = getClient();\n  return client?.getOptions().enabled !== false && !!client?.getTransport();\n}\n\n/**\n * Add an event processor.\n * This will be added to the current isolation scope, ensuring any event that is processed in the current execution\n * context will have the processor applied.\n */\nexport function addEventProcessor(callback: EventProcessor): void {\n  getIsolationScope().addEventProcessor(callback);\n}\n\n/**\n * Start a session on the current isolation scope.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns the new active session\n */\nexport function startSession(context?: SessionContext): Session {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  // Will fetch userAgent if called from browser sdk\n  const { userAgent } = GLOBAL_OBJ.navigator || {};\n\n  const session = makeSession({\n    user: currentScope.getUser() || isolationScope.getUser(),\n    ...(userAgent && { userAgent }),\n    ...context,\n  });\n\n  // End existing session if there's one\n  const currentSession = isolationScope.getSession();\n  if (currentSession?.status === 'ok') {\n    updateSession(currentSession, { status: 'exited' });\n  }\n\n  endSession();\n\n  // Afterwards we set the new session on the scope\n  isolationScope.setSession(session);\n\n  return session;\n}\n\n/**\n * End the session on the current isolation scope.\n */\nexport function endSession(): void {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session) {\n    closeSession(session);\n  }\n  _sendSessionUpdate();\n\n  // the session is over; take it off of the scope\n  isolationScope.setSession();\n}\n\n/**\n * Sends the current Session on the scope\n */\nfunction _sendSessionUpdate(): void {\n  const isolationScope = getIsolationScope();\n  const client = getClient();\n  const session = isolationScope.getSession();\n  if (session && client) {\n    client.captureSession(session);\n  }\n}\n\n/**\n * Sends the current session on the scope to Sentry\n *\n * @param end If set the session will be marked as exited and removed from the scope.\n *            Defaults to `false`.\n */\nexport function captureSession(end: boolean = false): void {\n  // both send the update and pull the session from the scope\n  if (end) {\n    endSession();\n    return;\n  }\n\n  // only send the update\n  _sendSessionUpdate();\n}\n","import type { Client } from '../client';\nimport { DEFAULT_ENVIRONMENT } from '../constants';\nimport { getGlobalScope } from '../currentScopes';\nimport { notifyEventProcessors } from '../eventProcessors';\nimport type { CaptureContext, ScopeContext } from '../scope';\nimport { Scope } from '../scope';\nimport type { Event, EventHint } from '../types-hoist/event';\nimport type { ClientOptions } from '../types-hoist/options';\nimport type { StackParser } from '../types-hoist/stacktrace';\nimport { applyScopeDataToEvent, mergeScopeData } from './applyScopeDataToEvent';\nimport { getFilenameToDebugIdMap } from './debug-ids';\nimport { addExceptionMechanism, uuid4 } from './misc';\nimport { normalize } from './normalize';\nimport { truncate } from './string';\nimport { dateTimestampInSeconds } from './time';\n\n/**\n * This type makes sure that we get either a CaptureContext, OR an EventHint.\n * It does not allow mixing them, which could lead to unexpected outcomes, e.g. this is disallowed:\n * { user: { id: '123' }, mechanism: { handled: false } }\n */\nexport type ExclusiveEventHintOrCaptureContext =\n  | (CaptureContext & Partial<{ [key in keyof EventHint]: never }>)\n  | (EventHint & Partial<{ [key in keyof ScopeContext]: never }>);\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nexport function prepareEvent(\n  options: ClientOptions,\n  event: Event,\n  hint: EventHint,\n  scope?: Scope,\n  client?: Client,\n  isolationScope?: Scope,\n): PromiseLike<Event | null> {\n  const { normalizeDepth = 3, normalizeMaxBreadth = 1_000 } = options;\n  const prepared: Event = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds(),\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  if (client) {\n    client.emit('applyFrameMetadata', event);\n  }\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  const finalScope = getFinalScope(scope, hint.captureContext);\n\n  if (hint.mechanism) {\n    addExceptionMechanism(prepared, hint.mechanism);\n  }\n\n  const clientEventProcessors = client ? client.getEventProcessors() : [];\n\n  // This should be the last thing called, since we want that\n  // {@link Scope.addEventProcessor} gets the finished prepared event.\n  // Merge scope data together\n  const data = getGlobalScope().getScopeData();\n\n  if (isolationScope) {\n    const isolationData = isolationScope.getScopeData();\n    mergeScopeData(data, isolationData);\n  }\n\n  if (finalScope) {\n    const finalScopeData = finalScope.getScopeData();\n    mergeScopeData(data, finalScopeData);\n  }\n\n  const attachments = [...(hint.attachments || []), ...data.attachments];\n  if (attachments.length) {\n    hint.attachments = attachments;\n  }\n\n  applyScopeDataToEvent(prepared, data);\n\n  const eventProcessors = [\n    ...clientEventProcessors,\n    // Run scope event processors _after_ all other processors\n    ...data.eventProcessors,\n  ];\n\n  const result = notifyEventProcessors(eventProcessors, prepared, hint);\n\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n * Enhances event using the client configuration.\n * It takes care of all \"static\" values like environment, release and `dist`,\n * as well as truncating overly long values.\n *\n * Only exported for tests.\n *\n * @param event event instance to be enhanced\n */\nexport function applyClientOptions(event: Event, options: ClientOptions): void {\n  const { environment, release, dist, maxValueLength } = options;\n\n  // empty strings do not make sense for environment, release, and dist\n  // so we handle them the same as if they were not provided\n  event.environment = event.environment || environment || DEFAULT_ENVIRONMENT;\n\n  if (!event.release && release) {\n    event.release = release;\n  }\n\n  if (!event.dist && dist) {\n    event.dist = dist;\n  }\n\n  const request = event.request;\n  if (request?.url && maxValueLength) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n\n  if (maxValueLength) {\n    event.exception?.values?.forEach(exception => {\n      if (exception.value) {\n        // Truncates error messages\n        exception.value = truncate(exception.value, maxValueLength);\n      }\n    });\n  }\n}\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nexport function applyDebugIds(event: Event, stackParser: StackParser): void {\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);\n\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (frame.filename) {\n        frame.debug_id = filenameDebugIdMap[frame.filename];\n      }\n    });\n  });\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nexport function applyDebugMeta(event: Event): void {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap: Record<string, string> = {};\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (frame.debug_id) {\n        if (frame.abs_path) {\n          filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n        } else if (frame.filename) {\n          filenameDebugIdMap[frame.filename] = frame.debug_id;\n        }\n        delete frame.debug_id;\n      }\n    });\n  });\n\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id,\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event: Event, integrationNames: string[]): void {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event: Event | null, depth: number, maxBreadth: number): Event | null {\n  if (!event) {\n    return null;\n  }\n\n  const normalized: Event = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth),\n        }),\n      })),\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth),\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth),\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth),\n    }),\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts?.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      return {\n        ...span,\n        ...(span.data && {\n          data: normalize(span.data, depth, maxBreadth),\n        }),\n      };\n    });\n  }\n\n  // event.contexts.flags (FeatureFlagContext) stores context for our feature\n  // flag integrations. It has a greater nesting depth than our other typed\n  // Contexts, so we re-normalize with a fixed depth of 3 here. We do not want\n  // to skip this in case of conflicting, user-provided context.\n  if (event.contexts?.flags && normalized.contexts) {\n    normalized.contexts.flags = normalize(event.contexts.flags, 3, maxBreadth);\n  }\n\n  return normalized;\n}\n\nfunction getFinalScope(scope: Scope | undefined, captureContext: CaptureContext | undefined): Scope | undefined {\n  if (!captureContext) {\n    return scope;\n  }\n\n  const finalScope = scope ? scope.clone() : new Scope();\n  finalScope.update(captureContext);\n  return finalScope;\n}\n\n/**\n * Parse either an `EventHint` directly, or convert a `CaptureContext` to an `EventHint`.\n * This is used to allow to update method signatures that used to accept a `CaptureContext` but should now accept an `EventHint`.\n */\nexport function parseEventHintOrCaptureContext(\n  hint: ExclusiveEventHintOrCaptureContext | undefined,\n): EventHint | undefined {\n  if (!hint) {\n    return undefined;\n  }\n\n  // If you pass a Scope or `() => Scope` as CaptureContext, we just return this as captureContext\n  if (hintIsScopeOrFunction(hint)) {\n    return { captureContext: hint };\n  }\n\n  if (hintIsScopeContext(hint)) {\n    return {\n      captureContext: hint,\n    };\n  }\n\n  return hint;\n}\n\nfunction hintIsScopeOrFunction(hint: CaptureContext | EventHint): hint is Scope | ((scope: Scope) => Scope) {\n  return hint instanceof Scope || typeof hint === 'function';\n}\n\ntype ScopeContextProperty = keyof ScopeContext;\nconst captureContextKeys: readonly ScopeContextProperty[] = [\n  'user',\n  'level',\n  'extra',\n  'contexts',\n  'tags',\n  'fingerprint',\n  'propagationContext',\n] as const;\n\nfunction hintIsScopeContext(hint: Partial<ScopeContext> | EventHint): hint is Partial<ScopeContext> {\n  return Object.keys(hint).some(key => captureContextKeys.includes(key as ScopeContextProperty));\n}\n","import React from 'react'\n\nexport const HeadManagerContext: React.Context<{\n  updateHead?: (state: any) => void\n  mountedInstances?: any\n  updateScripts?: (state: any) => void\n  scripts?: any\n  getIsSsr?: () => boolean\n\n  // Used in app directory, to render script tags as server components.\n  appDir?: boolean\n  nonce?: string\n}> = React.createContext({})\n\nif (process.env.NODE_ENV !== 'production') {\n  HeadManagerContext.displayName = 'HeadManagerContext'\n}\n"],"names":["warnOnce","_","process","env","NODE_ENV","warnings","Set","msg","has","console","warn","add","disableSmoothScrollDuringRouteTransition","fn","options","onlyHashChange","htmlElement","document","documentElement","hasDataAttribute","dataset","scrollBehavior","getComputedStyle","existing","style","dontForceLayout","getClientRects","styles","error","fontFamily","height","textAlign","display","flexDirection","alignItems","justifyContent","text","fontSize","fontWeight","lineHeight","margin","DefaultGlobalError","digest","html","id","head","body","HandleISRError","div","h2","window","location","hostname","p","HeadManagerContext","React","createContext","displayName"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]}}]
}